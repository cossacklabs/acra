// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package grpc_api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ReaderClient is the client API for Reader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReaderClient interface {
	Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error)
}

type readerClient struct {
	cc grpc.ClientConnInterface
}

func NewReaderClient(cc grpc.ClientConnInterface) ReaderClient {
	return &readerClient{cc}
}

func (c *readerClient) Decrypt(ctx context.Context, in *DecryptRequest, opts ...grpc.CallOption) (*DecryptResponse, error) {
	out := new(DecryptResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.Reader/Decrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReaderServer is the server API for Reader service.
// All implementations must embed UnimplementedReaderServer
// for forward compatibility
type ReaderServer interface {
	Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error)
	mustEmbedUnimplementedReaderServer()
}

// UnimplementedReaderServer must be embedded to have forward compatible implementations.
type UnimplementedReaderServer struct {
}

func (UnimplementedReaderServer) Decrypt(context.Context, *DecryptRequest) (*DecryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Decrypt not implemented")
}
func (UnimplementedReaderServer) mustEmbedUnimplementedReaderServer() {}

// UnsafeReaderServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReaderServer will
// result in compilation errors.
type UnsafeReaderServer interface {
	mustEmbedUnimplementedReaderServer()
}

func RegisterReaderServer(s grpc.ServiceRegistrar, srv ReaderServer) {
	s.RegisterService(&Reader_ServiceDesc, srv)
}

func _Reader_Decrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReaderServer).Decrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.Reader/Decrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReaderServer).Decrypt(ctx, req.(*DecryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Reader_ServiceDesc is the grpc.ServiceDesc for Reader service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Reader_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_api.Reader",
	HandlerType: (*ReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Decrypt",
			Handler:    _Reader_Decrypt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// WriterClient is the client API for Writer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WriterClient interface {
	Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error)
}

type writerClient struct {
	cc grpc.ClientConnInterface
}

func NewWriterClient(cc grpc.ClientConnInterface) WriterClient {
	return &writerClient{cc}
}

func (c *writerClient) Encrypt(ctx context.Context, in *EncryptRequest, opts ...grpc.CallOption) (*EncryptResponse, error) {
	out := new(EncryptResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.Writer/Encrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WriterServer is the server API for Writer service.
// All implementations must embed UnimplementedWriterServer
// for forward compatibility
type WriterServer interface {
	Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error)
	mustEmbedUnimplementedWriterServer()
}

// UnimplementedWriterServer must be embedded to have forward compatible implementations.
type UnimplementedWriterServer struct {
}

func (UnimplementedWriterServer) Encrypt(context.Context, *EncryptRequest) (*EncryptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Encrypt not implemented")
}
func (UnimplementedWriterServer) mustEmbedUnimplementedWriterServer() {}

// UnsafeWriterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WriterServer will
// result in compilation errors.
type UnsafeWriterServer interface {
	mustEmbedUnimplementedWriterServer()
}

func RegisterWriterServer(s grpc.ServiceRegistrar, srv WriterServer) {
	s.RegisterService(&Writer_ServiceDesc, srv)
}

func _Writer_Encrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WriterServer).Encrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.Writer/Encrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WriterServer).Encrypt(ctx, req.(*EncryptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Writer_ServiceDesc is the grpc.ServiceDesc for Writer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Writer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_api.Writer",
	HandlerType: (*WriterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Encrypt",
			Handler:    _Writer_Encrypt_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// TokenizatorClient is the client API for Tokenizator service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TokenizatorClient interface {
	Tokenize(ctx context.Context, in *TokenizeRequest, opts ...grpc.CallOption) (*TokenizeResponse, error)
	Detokenize(ctx context.Context, in *TokenizeRequest, opts ...grpc.CallOption) (*TokenizeResponse, error)
}

type tokenizatorClient struct {
	cc grpc.ClientConnInterface
}

func NewTokenizatorClient(cc grpc.ClientConnInterface) TokenizatorClient {
	return &tokenizatorClient{cc}
}

func (c *tokenizatorClient) Tokenize(ctx context.Context, in *TokenizeRequest, opts ...grpc.CallOption) (*TokenizeResponse, error) {
	out := new(TokenizeResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.Tokenizator/Tokenize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenizatorClient) Detokenize(ctx context.Context, in *TokenizeRequest, opts ...grpc.CallOption) (*TokenizeResponse, error) {
	out := new(TokenizeResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.Tokenizator/Detokenize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TokenizatorServer is the server API for Tokenizator service.
// All implementations must embed UnimplementedTokenizatorServer
// for forward compatibility
type TokenizatorServer interface {
	Tokenize(context.Context, *TokenizeRequest) (*TokenizeResponse, error)
	Detokenize(context.Context, *TokenizeRequest) (*TokenizeResponse, error)
	mustEmbedUnimplementedTokenizatorServer()
}

// UnimplementedTokenizatorServer must be embedded to have forward compatible implementations.
type UnimplementedTokenizatorServer struct {
}

func (UnimplementedTokenizatorServer) Tokenize(context.Context, *TokenizeRequest) (*TokenizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Tokenize not implemented")
}
func (UnimplementedTokenizatorServer) Detokenize(context.Context, *TokenizeRequest) (*TokenizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Detokenize not implemented")
}
func (UnimplementedTokenizatorServer) mustEmbedUnimplementedTokenizatorServer() {}

// UnsafeTokenizatorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TokenizatorServer will
// result in compilation errors.
type UnsafeTokenizatorServer interface {
	mustEmbedUnimplementedTokenizatorServer()
}

func RegisterTokenizatorServer(s grpc.ServiceRegistrar, srv TokenizatorServer) {
	s.RegisterService(&Tokenizator_ServiceDesc, srv)
}

func _Tokenizator_Tokenize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenizatorServer).Tokenize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.Tokenizator/Tokenize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenizatorServer).Tokenize(ctx, req.(*TokenizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Tokenizator_Detokenize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenizatorServer).Detokenize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.Tokenizator/Detokenize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenizatorServer).Detokenize(ctx, req.(*TokenizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Tokenizator_ServiceDesc is the grpc.ServiceDesc for Tokenizator service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Tokenizator_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_api.Tokenizator",
	HandlerType: (*TokenizatorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Tokenize",
			Handler:    _Tokenizator_Tokenize_Handler,
		},
		{
			MethodName: "Detokenize",
			Handler:    _Tokenizator_Detokenize_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// ReaderSymClient is the client API for ReaderSym service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReaderSymClient interface {
	DecryptSym(ctx context.Context, in *DecryptSymRequest, opts ...grpc.CallOption) (*DecryptSymResponse, error)
}

type readerSymClient struct {
	cc grpc.ClientConnInterface
}

func NewReaderSymClient(cc grpc.ClientConnInterface) ReaderSymClient {
	return &readerSymClient{cc}
}

func (c *readerSymClient) DecryptSym(ctx context.Context, in *DecryptSymRequest, opts ...grpc.CallOption) (*DecryptSymResponse, error) {
	out := new(DecryptSymResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.ReaderSym/DecryptSym", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReaderSymServer is the server API for ReaderSym service.
// All implementations must embed UnimplementedReaderSymServer
// for forward compatibility
type ReaderSymServer interface {
	DecryptSym(context.Context, *DecryptSymRequest) (*DecryptSymResponse, error)
	mustEmbedUnimplementedReaderSymServer()
}

// UnimplementedReaderSymServer must be embedded to have forward compatible implementations.
type UnimplementedReaderSymServer struct {
}

func (UnimplementedReaderSymServer) DecryptSym(context.Context, *DecryptSymRequest) (*DecryptSymResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptSym not implemented")
}
func (UnimplementedReaderSymServer) mustEmbedUnimplementedReaderSymServer() {}

// UnsafeReaderSymServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReaderSymServer will
// result in compilation errors.
type UnsafeReaderSymServer interface {
	mustEmbedUnimplementedReaderSymServer()
}

func RegisterReaderSymServer(s grpc.ServiceRegistrar, srv ReaderSymServer) {
	s.RegisterService(&ReaderSym_ServiceDesc, srv)
}

func _ReaderSym_DecryptSym_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecryptSymRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReaderSymServer).DecryptSym(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.ReaderSym/DecryptSym",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReaderSymServer).DecryptSym(ctx, req.(*DecryptSymRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReaderSym_ServiceDesc is the grpc.ServiceDesc for ReaderSym service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReaderSym_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_api.ReaderSym",
	HandlerType: (*ReaderSymServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DecryptSym",
			Handler:    _ReaderSym_DecryptSym_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// WriterSymClient is the client API for WriterSym service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WriterSymClient interface {
	EncryptSym(ctx context.Context, in *EncryptSymRequest, opts ...grpc.CallOption) (*EncryptSymResponse, error)
}

type writerSymClient struct {
	cc grpc.ClientConnInterface
}

func NewWriterSymClient(cc grpc.ClientConnInterface) WriterSymClient {
	return &writerSymClient{cc}
}

func (c *writerSymClient) EncryptSym(ctx context.Context, in *EncryptSymRequest, opts ...grpc.CallOption) (*EncryptSymResponse, error) {
	out := new(EncryptSymResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.WriterSym/EncryptSym", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WriterSymServer is the server API for WriterSym service.
// All implementations must embed UnimplementedWriterSymServer
// for forward compatibility
type WriterSymServer interface {
	EncryptSym(context.Context, *EncryptSymRequest) (*EncryptSymResponse, error)
	mustEmbedUnimplementedWriterSymServer()
}

// UnimplementedWriterSymServer must be embedded to have forward compatible implementations.
type UnimplementedWriterSymServer struct {
}

func (UnimplementedWriterSymServer) EncryptSym(context.Context, *EncryptSymRequest) (*EncryptSymResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptSym not implemented")
}
func (UnimplementedWriterSymServer) mustEmbedUnimplementedWriterSymServer() {}

// UnsafeWriterSymServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WriterSymServer will
// result in compilation errors.
type UnsafeWriterSymServer interface {
	mustEmbedUnimplementedWriterSymServer()
}

func RegisterWriterSymServer(s grpc.ServiceRegistrar, srv WriterSymServer) {
	s.RegisterService(&WriterSym_ServiceDesc, srv)
}

func _WriterSym_EncryptSym_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EncryptSymRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WriterSymServer).EncryptSym(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.WriterSym/EncryptSym",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WriterSymServer).EncryptSym(ctx, req.(*EncryptSymRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WriterSym_ServiceDesc is the grpc.ServiceDesc for WriterSym service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WriterSym_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_api.WriterSym",
	HandlerType: (*WriterSymServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EncryptSym",
			Handler:    _WriterSym_EncryptSym_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// SearchableEncryptionClient is the client API for SearchableEncryption service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SearchableEncryptionClient interface {
	EncryptSearchable(ctx context.Context, in *SearchableEncryptionRequest, opts ...grpc.CallOption) (*SearchableEncryptionResponse, error)
	DecryptSearchable(ctx context.Context, in *SearchableDecryptionRequest, opts ...grpc.CallOption) (*SearchableDecryptionResponse, error)
	EncryptSymSearchable(ctx context.Context, in *SearchableSymEncryptionRequest, opts ...grpc.CallOption) (*SearchableSymEncryptionResponse, error)
	DecryptSymSearchable(ctx context.Context, in *SearchableSymDecryptionRequest, opts ...grpc.CallOption) (*SearchableSymDecryptionResponse, error)
	GenerateQueryHash(ctx context.Context, in *QueryHashRequest, opts ...grpc.CallOption) (*QueryHashResponse, error)
}

type searchableEncryptionClient struct {
	cc grpc.ClientConnInterface
}

func NewSearchableEncryptionClient(cc grpc.ClientConnInterface) SearchableEncryptionClient {
	return &searchableEncryptionClient{cc}
}

func (c *searchableEncryptionClient) EncryptSearchable(ctx context.Context, in *SearchableEncryptionRequest, opts ...grpc.CallOption) (*SearchableEncryptionResponse, error) {
	out := new(SearchableEncryptionResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.SearchableEncryption/EncryptSearchable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchableEncryptionClient) DecryptSearchable(ctx context.Context, in *SearchableDecryptionRequest, opts ...grpc.CallOption) (*SearchableDecryptionResponse, error) {
	out := new(SearchableDecryptionResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.SearchableEncryption/DecryptSearchable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchableEncryptionClient) EncryptSymSearchable(ctx context.Context, in *SearchableSymEncryptionRequest, opts ...grpc.CallOption) (*SearchableSymEncryptionResponse, error) {
	out := new(SearchableSymEncryptionResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.SearchableEncryption/EncryptSymSearchable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchableEncryptionClient) DecryptSymSearchable(ctx context.Context, in *SearchableSymDecryptionRequest, opts ...grpc.CallOption) (*SearchableSymDecryptionResponse, error) {
	out := new(SearchableSymDecryptionResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.SearchableEncryption/DecryptSymSearchable", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchableEncryptionClient) GenerateQueryHash(ctx context.Context, in *QueryHashRequest, opts ...grpc.CallOption) (*QueryHashResponse, error) {
	out := new(QueryHashResponse)
	err := c.cc.Invoke(ctx, "/grpc_api.SearchableEncryption/GenerateQueryHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchableEncryptionServer is the server API for SearchableEncryption service.
// All implementations must embed UnimplementedSearchableEncryptionServer
// for forward compatibility
type SearchableEncryptionServer interface {
	EncryptSearchable(context.Context, *SearchableEncryptionRequest) (*SearchableEncryptionResponse, error)
	DecryptSearchable(context.Context, *SearchableDecryptionRequest) (*SearchableDecryptionResponse, error)
	EncryptSymSearchable(context.Context, *SearchableSymEncryptionRequest) (*SearchableSymEncryptionResponse, error)
	DecryptSymSearchable(context.Context, *SearchableSymDecryptionRequest) (*SearchableSymDecryptionResponse, error)
	GenerateQueryHash(context.Context, *QueryHashRequest) (*QueryHashResponse, error)
	mustEmbedUnimplementedSearchableEncryptionServer()
}

// UnimplementedSearchableEncryptionServer must be embedded to have forward compatible implementations.
type UnimplementedSearchableEncryptionServer struct {
}

func (UnimplementedSearchableEncryptionServer) EncryptSearchable(context.Context, *SearchableEncryptionRequest) (*SearchableEncryptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptSearchable not implemented")
}
func (UnimplementedSearchableEncryptionServer) DecryptSearchable(context.Context, *SearchableDecryptionRequest) (*SearchableDecryptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptSearchable not implemented")
}
func (UnimplementedSearchableEncryptionServer) EncryptSymSearchable(context.Context, *SearchableSymEncryptionRequest) (*SearchableSymEncryptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EncryptSymSearchable not implemented")
}
func (UnimplementedSearchableEncryptionServer) DecryptSymSearchable(context.Context, *SearchableSymDecryptionRequest) (*SearchableSymDecryptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecryptSymSearchable not implemented")
}
func (UnimplementedSearchableEncryptionServer) GenerateQueryHash(context.Context, *QueryHashRequest) (*QueryHashResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GenerateQueryHash not implemented")
}
func (UnimplementedSearchableEncryptionServer) mustEmbedUnimplementedSearchableEncryptionServer() {}

// UnsafeSearchableEncryptionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearchableEncryptionServer will
// result in compilation errors.
type UnsafeSearchableEncryptionServer interface {
	mustEmbedUnimplementedSearchableEncryptionServer()
}

func RegisterSearchableEncryptionServer(s grpc.ServiceRegistrar, srv SearchableEncryptionServer) {
	s.RegisterService(&SearchableEncryption_ServiceDesc, srv)
}

func _SearchableEncryption_EncryptSearchable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchableEncryptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchableEncryptionServer).EncryptSearchable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.SearchableEncryption/EncryptSearchable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchableEncryptionServer).EncryptSearchable(ctx, req.(*SearchableEncryptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchableEncryption_DecryptSearchable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchableDecryptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchableEncryptionServer).DecryptSearchable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.SearchableEncryption/DecryptSearchable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchableEncryptionServer).DecryptSearchable(ctx, req.(*SearchableDecryptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchableEncryption_EncryptSymSearchable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchableSymEncryptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchableEncryptionServer).EncryptSymSearchable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.SearchableEncryption/EncryptSymSearchable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchableEncryptionServer).EncryptSymSearchable(ctx, req.(*SearchableSymEncryptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchableEncryption_DecryptSymSearchable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchableSymDecryptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchableEncryptionServer).DecryptSymSearchable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.SearchableEncryption/DecryptSymSearchable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchableEncryptionServer).DecryptSymSearchable(ctx, req.(*SearchableSymDecryptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchableEncryption_GenerateQueryHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryHashRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchableEncryptionServer).GenerateQueryHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc_api.SearchableEncryption/GenerateQueryHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchableEncryptionServer).GenerateQueryHash(ctx, req.(*QueryHashRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SearchableEncryption_ServiceDesc is the grpc.ServiceDesc for SearchableEncryption service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SearchableEncryption_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpc_api.SearchableEncryption",
	HandlerType: (*SearchableEncryptionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EncryptSearchable",
			Handler:    _SearchableEncryption_EncryptSearchable_Handler,
		},
		{
			MethodName: "DecryptSearchable",
			Handler:    _SearchableEncryption_DecryptSearchable_Handler,
		},
		{
			MethodName: "EncryptSymSearchable",
			Handler:    _SearchableEncryption_EncryptSymSearchable_Handler,
		},
		{
			MethodName: "DecryptSymSearchable",
			Handler:    _SearchableEncryption_DecryptSymSearchable_Handler,
		},
		{
			MethodName: "GenerateQueryHash",
			Handler:    _SearchableEncryption_GenerateQueryHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}
